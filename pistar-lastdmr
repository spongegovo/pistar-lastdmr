#!/usr/bin/env bash
 
# Ken Cormack
# May 2021
# https://github.com/kencormack/pistar-lastdmr
VERSION=0.94

# NOTE: This script was written for pi-star 4.1.4, for the DMR mode ONLY.
# If the logfile data changes in any way with future releases of pi-star,
# or if you want to display modes other than DMR (YSF, D-Star, P25, etc.)
# you will need to modify this script accordingly.  I only use DMR, so
# that's the mode I wrote this for.

set -o allexport

SCRIPT="$(readlink -f "${0}")"
PARM="${1}"

# pi-star's log entries are stamped with UTC date and time stamps.
# We get the system's UTC offset (assuming locale is set) so that
# we can convert those to the user's timezone and date format  later.
UTC_OFFSET="$(date +%z)"
OFFSET_DIF="$(echo "${UTC_OFFSET}" | cut -c1)"
OFFSET_HRS="$(echo "${UTC_OFFSET}" | cut -c2-3)"
OFFSET_MIN="$(echo "${UTC_OFFSET}" | cut -c4-5)"

# Define some ways to make things bold, use different colors, and so on.
# See "man tput" for descriptions of each tput parameter used here.
SGR0=$(tput sgr0)
BOLD=$(tput bold)
# REV=$(tput rev)
# BLINK=$(tput blink)
# BLACK=$(tput setaf 0)
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
YELLOW=$(tput setaf 3)
BLUE=$(tput setaf 4)
MAGENTA=$(tput setaf 5)
CYAN=$(tput setaf 6)
WHITE=$(tput setaf 7)

# For grepping stuff that includes tabs
GTAB=$'\t'

# Find the latest log in the directory
LATEST_LOG="$(ls -1tr /var/log/pi-star/MMDVM*.log | tail -1)"
# Get it's fully qualified path
WORKING_LOG="$(readlink -f "${LATEST_LOG}")"

# Other files we'll be consulting
DMRIDS=/usr/local/etc/DMRIds.dat
TGLIST=/usr/local/etc/TGList_BM.txt
MY_LIST=/usr/local/etc/MY_LIST.txt

fnVERSION()
{
  echo "${BOLD}-----------------${SGR0} pistar-lastdmr v${VERSION} ${BOLD}---------------------${SGR0}"
}

clear

# Continuously watch the logfile for DMR-related data (only).
tail -f "${WORKING_LOG}" | grep --line-buffered "DMR" | while read -r RECORD
do
  DATE_STAMP="$(echo "${RECORD}" | awk '{ print $2 }')"
  TIME_STAMP="$(echo "${RECORD}" | awk '{ print $3 }')"
  DATE_TIME="$(date -d "$(date -Iseconds -d "${DATE_STAMP} ${TIME_STAMP}") ${OFFSET_DIF} ${OFFSET_HRS} hours ${OFFSET_DIF} ${OFFSET_MIN} minutes")"

  TIME_SLOT="$(echo "${RECORD}" | awk '{ print $6 }' | cut -f1 -d",")"
  SOURCE="$(echo "${RECORD}" | awk '{ print $8 }' | sed 's/network/NET/')"

  # "private" call log entries lack " TG " in the log line, which skews
  # the data returned when awk parses positional fields.  These few
  # lines will inject a bogus field to substitute for the missing "TG",
  # so as not to skew positional fields used by awk.
  if echo "${RECORD}" | grep -q -E -i "voice header|data header|end of voice"
  then
    IS_TG="$(echo "${RECORD}" | grep " TG ")"
    if [[ "${IS_TG}" = "" ]]
    then
      RECORD="$(echo "${RECORD}" | sed 's/ to / to CONTACT /')"
    fi
  fi

  if echo "${RECORD}" | grep -q -E -i "voice header|data header"
  then
    FROM="$(echo "${RECORD}" | awk '{ print $12 }')"
    FROM_NAME="$(grep "${GTAB}${FROM}${GTAB}" "${DMRIDS}" | awk '{ print $NF }' | sort -u)"
    if [[ "${FROM_NAME}" = "" ]]
    then
      FROM_NAME="$(grep "^${FROM};" "${TGLIST}" | cut -f3 -d";")"
    fi

    # "private" call log entries lack "TG" in the log line
    IS_TG="$(echo "${RECORD}" | grep " TG ")"
    if [[ "${IS_TG}" = "" ]]
    then
      TO="$(echo "${RECORD}" | awk '{ print $15 }' | cut -f1 -d",")"
    else
      TO="$(echo "${RECORD}" | awk '{ print $NF }')"
    fi
    TO_NAME="$(grep "${GTAB}${TO}${GTAB}" "${DMRIDS}" | awk '{ print $NF }' | sort -u)"
    if [[ "${TO_NAME}" = "" ]]
    then
      TO_NAME="$(grep "^${TO};" "${TGLIST}" | cut -f3 -d";")"

      # Some talkgroups do not have names given, in the TGList_BM.txt
      # file that pi-star updates automatically.  These next few lines
      # allow the user to create a second lookup file in which they
      # can list talkgroups and contacts they use, that are not present
      # in the TGList_BM.txt file.  That file is /usr/local/etc/MY_LIST.txt
      # and entries in that file must be in the same format as the 
      # TGList_BM.txt file - DO NOT INCLUDE SPACES.
      #
      # Examples:
      #   26283;0;Region-Muenchen;TG26283
      #   26287;0;Allgaeu-Bodensee;TG26287
      #
      if [[ "${TO_NAME}" = "" ]] && [[ -f "${MY_LIST}" ]]
      then
        TO_NAME="$(grep "^${TO};" "${MY_LIST}" | cut -f3 -d";")"
      fi
    fi

    TYPE="$(echo "${RECORD}" | awk '{ print $9 }')"
    if [[ "${TYPE}" = "data" ]]
    then
      TYPE="${MAGENTA}Data ($(echo "${RECORD}" | awk '{ print $16 }') Blocks)"
    else
      TYPE="${CYAN}Voice Call"
    fi

    # If you install "figlet", this will detect and utilize it,
    # to add the large font display of the contact's callsign.
    # Otherwise, the large font callsign will be skipped, to
    # save screen space.
    #
    #     rpi-rw
    #     sudo apt install figlet
    #     rpi-ro
    #
    # However, even if figlet is installed, you can still turn
    # off the large font display callsign to save screen space,
    # by passing the "--nobig" parameter to this script:
    #
    #     pistar-lastdmr --nobig
    #
    if [[ "${PARM}" != "--nobig" ]]
    then
      if command -v figlet > /dev/null 2>&1
      then
        echo -n "${BOLD}"
        figlet -f small "${FROM}"
        echo -n "${SGR0}"
      fi
    fi

    echo "When: ${BLUE}${BOLD}${DATE_TIME}${SGR0}${WHITE}"

    P_FROM_NAME="$(printf "%-15s" "(${FROM_NAME})")"
    P_TO_NAME="$(printf "%-15s" "(${TO_NAME})")"
    echo -e -n "From: ${BOLD}${FROM} ${P_FROM_NAME}${SGR0}\r"
    tput cuf 31
    echo    " To: ${BOLD}${TO} ${P_TO_NAME}${SGR0}${WHITE}"

    echo -e "Mode: ${CYAN}${BOLD}DMR TS${TIME_SLOT}${SGR0}${WHITE}\tSource: ${CYAN}${BOLD}${SOURCE}${SGR0}${WHITE}\tType: ${BOLD}${TYPE}${SGR0}${WHITE}"
  else
    if echo "${RECORD}" | grep -q "end of voice"
    then
      SECS="$(echo "${RECORD}" | awk '{ print $18 }')"

      # If network traffic...
      if [[ "$(echo "${RECORD}" | grep "RSSI:")" = "" ]]
      then
        BER="$(echo "${RECORD}" | awk '{ print $NF }' | cut -f1 -d'%')"
        BER_COLOR="${WHITE}"
        if [[ "$(expr "${BER}" '>=' 0.0)" -eq 1 ]] && [[ "$(expr "${BER}" '<=' 1.9)" -eq 1 ]]
        then
          BER_COLOR="${GREEN}"
        else
          if [[ "$(expr "${BER}" '>=' 2.0)" -eq 1 ]] && [[ "$(expr "${BER}" '<=' 4.9)" -eq 1 ]]
          then
            BER_COLOR="${YELLOW}"
          else
            if [[ "$(expr "${BER}" '>=' 5.0)" -eq 1 ]]
            then
              BER_COLOR="${RED}"
            fi
          fi
        fi

        LOSS="$(echo "${RECORD}" | cut -f4 -d"," | awk '{ print $1 }' | sed 's/%//')"
        LOSS_COLOR="${WHITE}"
        if [[ "$(expr "${LOSS}" '=' 1.0)" -eq 1 ]]
        then
          LOSS_COLOR="${GREEN}"
        else
          if [[ "$(expr "${LOSS}" '>' 1.0)" -eq 1 ]] && [[ "$(expr "${LOSS}" '<' 3.0)" -eq 1 ]]
          then
            LOSS_COLOR="${YELLOW}"
          else
            if [[ "$(expr "${LOSS}" '>' 3.0)" -eq 1 ]]
            then
              LOSS_COLOR="${RED}"
            fi
          fi
        fi

        echo -e "Dur:  ${BLUE}${BOLD}${SECS}${SGR0}${WHITE}s\tBER: ${BER_COLOR}${BOLD}${BER}%${SGR0}${WHITE}\t${LOSS_COLOR}${BOLD}${LOSS}%${SGR0}${WHITE} Packet Loss"
      else
        # Else, local RF traffic...
        BER="$(echo "${RECORD}" | awk '{ print $21 }' | cut -f1 -d"," | cut -f1 -d'%')"
        BER_COLOR="${WHITE}"
        if [[ "$(expr "${BER}" '>=' 0.0)" -eq 1 ]] && [[ "$(expr "${BER}" '<=' 1.9)" -eq 1 ]]
        then
          BER_COLOR="${GREEN}"
        else
          if [[ "$(expr "${BER}" '>=' 2.0)" -eq 1 ]] && [[ "$(expr "${BER}" '<=' 4.9)" -eq 1 ]]
          then
            BER_COLOR="${YELLOW}"
          else
            if [[ "$(expr "${BER}" '>=' 5.0)" -eq 1 ]]
            then
              BER_COLOR="${RED}"
            fi
          fi
        fi

        # What follows converts RSSI dBm to S-Meter values.
        # We look for S9 through S1 signal strength...
        RSSI="$(echo "${RECORD}" | awk '{ print $23 }')"
        DBM="$(echo "${RSSI}" | cut -f1 -d"/" | cut -f2 -d"-")"

        # Excellent...
        SMETER_COLOR="${GREEN}"
        if [[ "${DBM}" -lt 93 ]]
        then
          # If stronger than S9, calculate how much over
          SMETER="S9+$((93-DBM))dB"
        else
          if [[ "${DBM}" -eq 93 ]]
          then
            SMETER="S9"
          else
            if [[ "${DBM}" -ge 99 ]] && [[ "${DBM}" -lt 93 ]]
            then
              SMETER="S8"
            else
              if [[ "${DBM}" -ge 85 ]] && [[ "${DBM}" -lt 105 ]]
              then
                SMETER="S7"
              else

                # Good...
                SMETER_COLOR="${YELLOW}"
                if [[ "${DBM}" -ge 105 ]] && [[ "${DBM}" -lt 111 ]]
                then
                  SMETER="S6"
                else
                  if [[ "${DBM}" -ge 111 ]] && [[ "${DBM}" -lt 117 ]]
                  then
                    SMETER="S5"
                  else
                    if [[ "${DBM}" -ge 117 ]] && [[ "${DBM}" -lt 123 ]]
                    then
                      SMETER="S4"
                    else
                      if [[ "${DBM}" -ge 123 ]] && [[ "${DBM}" -lt 129 ]]
                      then
                        SMETER="S3"
                      else

                        # Weak...
                        SMETER_COLOR="${RED}"
                        if [[ "${DBM}" -ge 129 ]] && [[ "${DBM}" -lt 135 ]]
                        then
                          SMETER="S2"
                        else
                          if [[ "${DBM}" -ge 135 ]] && [[ "${DBM}" -lt 141 ]]
                          then
                            SMETER="S1"
                          else
                            # Things are REALLY bad, if you can't even reach S1 signal strength
                            if [[ "${DBM}" -ge 141 ]]
                            then
                              SMETER="S0"
                            fi
                          fi
                        fi
                      fi
                    fi
                  fi
                fi
              fi
            fi
          fi
        fi

        echo -e "Dur:  ${BLUE}${BOLD}${SECS}${SGR0}${WHITE}s\tBER: ${BER_COLOR}${BOLD}${BER}%${SGR0}${WHITE}\tRSSI: ${SMETER_COLOR}${BOLD}${SMETER} (-${DBM} dBm)${SGR0}${WHITE}"
      fi
      fnVERSION
    else
      if echo "${RECORD}" | grep -q "ended network data"
      then
        fnVERSION
      fi
    fi
  fi

  # Check again for the latest log
  LATEST_LOG="$(ls -1tr /var/log/pi-star/MMDVM*.log | tail -1)"
  NEW_LOG="$(readlink -f "${LATEST_LOG}")"

  # Compare the newest logfile name to the logfile name we've been using
  if [[ "${WORKING_LOG}" != "${NEW_LOG}" ]]
  then
    # If the logfile name has changed, re-launch this script
    # so that it can pick up the new latest log.
    exec "${SCRIPT}"
  fi
done
