#!/bin/bash
set -o allexport

SCRIPT="$(readlink -f ${0})"
PARM="${1}"

# pi-star's log entries are stamped with UTC date and time.
# We get the system's offset from UTC (assuming locale is set) so that
# we can convert those UTC date/timestamps later.
UTC_OFFSET="$(date +%z)"
OFFSET_DIF="$(echo "${UTC_OFFSET}" | cut -c1)"
OFFSET_HRS="$(echo "${UTC_OFFSET}" | cut -c2-3)"
OFFSET_MIN="$(echo "${UTC_OFFSET}" | cut -c4-5)"

# NOTE: This script was written for pi-star 4.1.4, for the DMR mode ONLY.
# If the logfile data changes in any way with future releases of pi-star,
# or if you want to display modes other than DMR (YSF, D-Star, P25, etc.)
# you will need to modify this script accordingly.  I only use DMR, so
# that's the mode I wrote this for.

# Define some ways to make things bold, use different colors, and so on.
# See "man tput" for descriptions of each tput parameter used here.
SGR0=$(tput sgr0)
BOLD=$(tput bold)
# BLINK=$(tput blink)
# BLACK=$(tput setaf 0)
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
YELLOW=$(tput setaf 3)
BLUE=$(tput setaf 4)
MAGENTA=$(tput setaf 5)
CYAN=$(tput setaf 6)
WHITE=$(tput setaf 7)

# For grepping stuff that includes tabs
GTAB=$'\t'

# Find the latest log in the directory
LATEST_LOG="$(ls -1tr /var/log/pi-star/MMDVM*.log | tail -1)"
# Get it's fully qualified path
WORKING_LOG="$(readlink -f "${LATEST_LOG}")"

# Other files we'll be consulting
DMRIDS=/usr/local/etc/DMRIds.dat
TGLIST=/usr/local/etc/TGList_BM.txt

clear

# Continuosly watch the logfile for DMR-related data (only).
tail -f "${WORKING_LOG}" | grep --line-buffered "DMR" | while read -r RECORD
do
  DATE_STAMP="$(echo "${RECORD}" | awk '{ print $2 }')"
  TIME_STAMP="$(echo "${RECORD}" | awk '{ print $3 }')"
  DATE_TIME="$(date -d "$(date -Iseconds -d "${DATE_STAMP} ${TIME_STAMP}") ${OFFSET_DIF} ${OFFSET_HRS} hours ${OFFSET_DIF} ${OFFSET_MIN} minutes")"

  TIME_SLOT="$(echo "${RECORD}" | awk '{ print $6 }' | cut -f1 -d",")"
  SOURCE="$(echo "${RECORD}" | awk '{ print $8 }' | sed 's/network/NET/')"

  if echo "${RECORD}" | grep -q -E -i "voice header|data header"
  then
    CALLSIGN="$(echo "${RECORD}" | awk '{ print $12 }')"
    NAME="$(grep "${GTAB}${CALLSIGN}${GTAB}" "${DMRIDS}" | awk '{ print $NF }' | sort -u)"
    TG_NUM="$(echo "${RECORD}" | awk '{ print $15 }' | cut -f1 -d",")"
    TG_NAME="$(grep "^${TG_NUM};" "${TGLIST}" | cut -f3 -d";")"
    TYPE="$(echo "${RECORD}" | awk '{ print $9 }')"
    if [ "${TYPE}" = "data" ]
    then
      TYPE="${MAGENTA}Data ($(echo "${RECORD}" | awk '{ print $16 }') Blocks)"
    else
      TYPE="${CYAN}Voice Call"
    fi

    # If you install "figlet", this will detect and utilize it,
    # to add the large font display of the contact's callsign.
    # Otherwise, the large font callsign will be skipped, to
    # save screen space.
    #
    #     rpi-rw
    #     sudp apt install figlet
    #     rpi-ro
    #
    # However, even if figlet is installed, you can still turn
    # off the large font display callsign to save screen space,
    # by passing the "--nobig" parameter to this script:
    #
    #     pistar-lastdmr --nobig
    #
    if [[ "${PARM}" != "--nobig" ]]
    then
      if command -v figlet > /dev/null 2>&1
      then
        echo -n "${BOLD}"
        figlet -f small "${CALLSIGN}"
        echo -n "${SGR0}"
      fi
    fi

    echo -e "Call: ${BOLD}${CALLSIGN}${SGR0}\tName: ${BOLD}${NAME}${SGR0}\tTG: ${GREEN}${BOLD}${TG_NUM} (${TG_NAME})${SGR0}${WHITE}"
    echo -e "When: ${BLUE}${BOLD}${DATE_TIME}${SGR0}${WHITE}"
  echo -e "Mode: ${CYAN}${BOLD}DMR TS${TIME_SLOT}${SGR0}${WHITE}\tSource: ${CYAN}${BOLD}${SOURCE}${SGR0}${WHITE}\tType: ${BOLD}${TYPE}${SGR0}${WHITE}"
  fi

  if echo "${RECORD}" | grep -q "end of voice"
  then
    DURATION="$(echo "${RECORD}" | awk '{ print $18 }')"

    # IF NETWORK TRAFIC...
    if [ "$(echo "${RECORD}" | grep "RSSI:")" = "" ]
    then
      BER="$(echo "${RECORD}" | awk '{ print $NF }' | cut -f1 -d'%')"
      BER_COLOR="${WHITE}"
      if [ $(expr ${BER} '>=' 0.0) -eq 1 ] && [ $(expr ${BER} '<=' 1.9) -eq 1 ]; then BER_COLOR="${GREEN}"; fi
      if [ $(expr ${BER} '>=' 2.0) -eq 1 ] && [ $(expr ${BER} '<=' 4.9) -eq 1 ]; then BER_COLOR="${YELLOW}"; fi
      if [ $(expr ${BER} '>=' 5.0) -eq 1 ]; then  BER_COLOR="${RED}"; fi

      LOSS="$(echo "${RECORD}" | awk '{ print $20 }' | cut -f1 -d'%')"
      LOSS_COLOR="${WHITE}"
      if [ ${LOSS} -eq 1 ] ; then LOSS_COLOR="${GREEN}"; fi
      if [ ${LOSS} -gt 1 ] && [[ ${LOSS} -le 3 ]] ; then LOSS_COLOR="${YELLOW}"; fi
      if [ ${LOSS} -gt 3 ] ; then LOSS_COLOR="${RED}"; fi

      echo -e "Dur: ${BLUE}${BOLD}${DURATION}${SGR0}${WHITE}s\tBER: ${BER_COLOR}${BOLD}${BER}%${SGR0}${WHITE}\t${LOSS_COLOR}${BOLD}${LOSS}%${SGR0}${WHITE} Packet Loss"
    else
      # ELSE, LOCAL RF TRAFFIC...
      BER="$(echo "${RECORD}" | awk '{ print $21 }' | cut -f1 -d"," | cut -f1 -d'%')"
      BER_COLOR="${WHITE}"
      if [ $(expr ${BER} '>=' 0.0) -eq 1 ] && [ $(expr ${BER} '<=' 1.9) -eq 1 ]; then BER_COLOR="${GREEN}"; fi
      if [ $(expr ${BER} '>=' 2.0) -eq 1 ] && [ $(expr ${BER} '<=' 4.9) -eq 1 ]; then BER_COLOR="${YELLOW}"; fi
      if [ $(expr ${BER} '>=' 5.0) -eq 1 ]; then  BER_COLOR="${RED}"; fi

      RSSI="$(echo "${RECORD}" | awk '{ print $23 }')"
      RSSI_COLOR="${WHITE}"

      echo -e "Dur: ${BLUE}${BOLD}${DURATION}${SGR0}${WHITE}s\tBER: ${BER_COLOR}${BOLD}${BER}%${SGR0}${WHITE}\tRSSI: ${RSSI_COLOR}${BOLD}${RSSI} dBm${SGR0}${WHITE}"
    fi
    echo "--------------------------------------------------------"
  else
    if echo "${RECORD}" | grep -q "ended network data"
    then
      echo "${MAGENTA}${BOLD}End of DMR Data Transmission${SGR0}${WHITE}"
      echo "--------------------------------------------------------"
    fi
  fi

  # Check again for the latest log
  LATEST_LOG="$(ls -1tr /var/log/pi-star/MMDVM*.log | tail -1)"
  NEW_LOG="$(readlink -f "${LATEST_LOG}")"

  # Compare the newest logfile name to the logfile name we've been using
  if [[ "${WORKING_LOG}" != "${NEW_LOG}" ]]
  then
    # If the logfile name has changed, re-launch this script
    # so that it can pick up the new latest log.
    exec "${SCRIPT}"
  fi
done
